## 1. Comparable
Реализуйте класс `TeamData`, который отслеживает информацию о студенческих командах, 
участвующих в соревновании по программированию. Класс имеет следующие открытые методы:

* `TeamData(name, problems)` конструктор с заданным именем команды и числом заданий. 
* `success(problem, time)` записывает удачное завершение данной задачи за данное время
* `solved()` возвращает число решенных заданий
* `time()` возвращает общее время потраченное на выполнение заданий
* `percentCorrect()` возвращает процент решенных заданий
* `toString()` выдает имя команды, число решенных заданий, число заданий и затраченное время.

Каждый раз, когда команда решит задачу, выполняется метод success с номером задания 
и временем выполнения. Объект `TeamData` должен хранить общее число решенных задач 
и время их выполнения. Хранить какие задания были решены, НЕ ТРЕБУЕТСЯ.

Далее пример выполнения:
```
    TeamData team1 = new TeamData("UW Red", 8); 
    team1.success(3, 18); 
    team1.success(4, 82); 
    team1.success(6, 130); 
    System.out.println(team1);	// UW Red solved 3 of 8 in 230 minutes
    team1.solved(); 			// 3
    team1.time(); 				// 230
    team1.percentCorrect(); 		// 37.5.
```

* Класс `TeamData` должен имплементировать интерфейс `Comparable<E>`. 
* Команды должны быть отсортированы по убыванию результата. 
* Сортировать, во-первых, по проценту решенных задач, далее по времени потраченному на решение заданий.
* Все параметры, отправленные в ваши методы валидны и общее число заданий больше нуля.

## 2. Collections
Написать метод `favoriteFoods` с параметрами список типа `Map` и целевой размер рейтинга. 

Список содержит информацию о том, как пользователи оценивают различные блюда. 
Метод возвращает другой список Map, с именами пользователей и соответствующим им 
 списком блюд с рейтингом выше заданного.
 
Во входном списке ключами являются имена пользователей (строки),
 а в значениях указан список пар с названием блюда и числом от 0.0 до 5.0. 
 
 Например:
 
```
{"Porter"={"pie"=5.0, "ice cream"=5.0, "mushrooms"=0.0}, 
 "Erik"={"chicken strips"=4.3, "cranberry sauce"=4.2}, 
 "Yael"={"lettuce"=2.4}, 
 "Ken"={}}
 ```
В данном примере видно, что `Porter` оценил `pie` и `ice cream` на 5 баллов, 
а mushrooms на 0. Тогда как `Yael` оценил `lettuce` на 2.4.

Таким образом, если вызвать метод favoriteFoods(ratings, 4.3); то получим следующий список: 
```
{"Erik" = ["chicken strips"], "Ken" = [], 
 "Porter" = ["ice cream", "pie"], "Yael" = []}
``` 
Список должен быть отсортирован по алфавиту, в том числе и названия блюд во внутренних списках. Метод не должен изменять заданный список. Также учитывайте, что в списке нет нулевых элементов.

## 3. LinkedList
Написать метод `removeAlternating` класса `LinkedIntList`, 
который чередует удаление узла из каждой пары узлов в списке. 

В первой паре должно быть удалено первое число, во второй – второе. 

В третьей паре он возвращается к первому удаляемому номеру, далее повторяется для следующих пар. 
Если список имеет нечетную длину, последнее значение не удаляется, 
поскольку оно не является частью пары. 

Значения, удаленные из списка, 
должны быть возвращены методом в новом `LinkedIntList`, 
причем значения заданы в том же порядке, что и исходный список. 

Пример выполнения программы:
```
// list1: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]

[1,  2,  3,  4,  5,  6,  7,  8,  9,  10,  11]
 |   |   |   |   |   |   |   |   |    |
 +---+   +---+   +---+   +---+   +----+
 pair1   pair2   pair3   pair4   pair5

LinkedIntList list2 = list1.removeAlternating(); 
// list1: [2, 3, 6, 7, 10, 11]; list2: [1, 4, 5, 8, 9]
```

Ограничения: 
- Вы можете добавить приватные, вспомогательные методы, однако вы не можете предполагать, что какие-либо конкретные методы доступны. 
- Вам разрешено определять свои собственные переменные типа `ListNode`, но вы не можете создавать какие-либо новые узлы.
- Также вы НЕ МОЖЕТЕ использовать вспомогательные структуры данных (массив, `List`, `String` и т. д.). 
- Вы также не можете изменять какие-либо поля данных узлов. Вы ДОЛЖНЫ решить эту проблему, переставив ссылки в списке. 
- Ваше решение должно выполняться за время O (n), где n - длина списка.

Ваша задача написать метод класса `LinkedIntList`. Структура классов представлена ниже:
```
 public class ListNode {
     public int data; // здесь хранятся данные
     public ListNode next; // ссылка на следующий элемент
	<constructors>
 }
 public class LinkedIntList {
     private ListNode front; // первый элемент списка
     <methods>
 }
```