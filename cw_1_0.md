# Подготовка к Контрольной работе №1
Будет 4 **письменных** задания. Всего на кр выделено 10 баллов. 
Для удобаства оценивания, максимальный балл равен 50, который будет разделен по коэффициенту.
Опечатки в синтаксисе не учитываются.
На кр будут задания по этим же темам.

## КР 1.1. (10 баллов)
**Наследования/Полиморфизм.** Представьте, что у вас есть следующие классы: 
```java
public class Clock extends Bear {
    public void method3() {
        System.out.println("Clock 3");
    }
}
public class Lamp extends Can {
    public void method1() {
        System.out.println("Lamp 1");
    }
    public void method3() {
        System.out.println("Lamp 3");
    }
}
public class Bear extends Can {
    public void method1() {
        System.out.println("Bear 1");
    }
    public void method3() {
        System.out.println("Bear 3");
        super.method3();
    }
}
public class Can {
    public void method2() {
        System.out.println("Can 2");
        method3();
    }
    public void method3() {
        System.out.println("Can 3");
    }
}
```
И заданы следующие переменные:
```java
    Object var1 = new Bear();
    Can var2 = new Can();
    Can var3 = new Lamp();
    Bear var4 = new Clock();
    Object var5 = new Can();
    Can var6 = new Clock();
``` 
Заполните следующую таблицу:
| Выражение                | Результат   |
|--------------------------|-------------|
| var1.method2();          | ___________ |
| var2.method2();          | ___________ |
| var3.method2();          | ___________ |
| var4.method2();          | ___________ |
| var5.method2();          | ___________ |
| var1.method3();          | ___________ |
| var2.method3();          | ___________ |
| var3.method3();          | ___________ |
| var6.method3();          | ___________ |
| ((Lamp)var6).method1();  | ___________ |
| ((Can)var1).method1();   | ___________ |
| ((Can)var1).method2();   | ___________ |
| ((Bear)var1).method3();  | ___________ |
| ((Clock)var1).method1(); | ___________ |
| ((Clock)var4).method2(); | ___________ |

Если результатов больше одной строки, разделяйте их слешами ("/").
Если вылезет ошибка, пишите  "compiler error" или "runtime error".

## КР 1.2. (10 баллов)
**Comparable.** Реализуйте класс PokemonTrainer, который хранит информацию о тренере покемонов и количество 
выигранных боев. Каждый объект PokemonTrainer хранит имя тренера, количество ачивок, общее число боев и число
победных боев.

```java
 PokemonTrainer(String name, int badges) // конструктор содержит имя и число ачивок, при этом число боев равно 0.

 getBadges() // выводит число ачивок

 getBattlePercent() 
/*  выводит вещественное число процента выигрыша. 
    Если тренер выиграл все бои, то должно вернуть число 100.0, 
    если проиграл все или еще не играл, то 0.0. */

 battle(boolean won) // записывает тренеру бой, true если выиграл, false в противном случае.
 toString() 
/*  выводит строку с именем, чилом ачивок и процентом выигрышей (или "боев не было"). 
    Процент боев нужно округлить, т.е. если процент равен 73.835, то нужно вывести 73%.
*/
```

Пример тестового запуска:
```java
 PokemonTrainer trainer1 = new PokemonTrainer("Sam", 1);
 PokemonTrainer trainer2 = new PokemonTrainer("Anika", 6);

 trainer2.getBadges(); // returns 6
 trainer1.battle(true); // records a battle win for trainer1
 trainer1.battle(false); // records a battle loss for trainer1
 trainer1.getBattlePercent(); // returns 50.0
 trainer2.getBattlePercent(); // returns 0.0
 trainer1.battle(false); // records a battle loss for trainer1
 trainer1.getBattlePercent(); // returns 33.3333333333333333
 trainer1.toString(); // returns "Sam has 1 badge(s) and a 33% win rate"
 trainer2.toString(); // returns "Anika has 6 badge(s) and no battles"

```

Класс PokemonTrainer должен быть сопоставим с другими объектами PokemonTrainer 
и должен реализовывать интерфейс Comparable. 
Тренеров необходимо отсортировать в порядке возрастания по проценту сражений.
Вы должны использовать полное значение процента битвы, а не усеченное. 
Тренеры с одинаковым процентом сражений должны быть упорядочены по количеству сыгранных сражений, 
причем тренеры, которые сражались чаще, считались «меньше», чем тренеры, которые сражались реже. 
Если все еще есть ничья, тренеры должны быть отсортированы в алфавитном порядке по имени.

## КР 1.3. (15 баллов)
**Коллекции.** Написать метод recordDate, который выдает информацию о свиданиях между двумя людьми.
Для каждого человека задается список типа Map, который хранит упорядоченный список людей, 
с которыми данный человек уже встречался.
Например, список должен хранить следующие записи для двух людей:
``` 
Michael => [Ashley, Samantha, Joshua, Brittany, Amanda, Amanda]
Amanda => [Michael, Daniel, Michael]
```
Свидания отсортированы в обратном порядке. В примере Майкл последний раз встречался с Эшли, а до этого с Самантой итд.
Обратите внимание, что с Амандой он встречался дважды. Все имена хранятся как строки.
Метод имеет три аргумента: список типа Map, и имена двух людей. Метод должен добавить запись в список для каждого человека
 и вывести число равное количеству свиданий. Таким образом, если мы выполним следующий код для состояния выше:
```java 
 int n = recordDate(dates, "Michael", "Amanda");
```
то должны получить такой результат:
```
  Michael => [Amanda, Ashley, Samantha, Joshua, Brittany, Amanda, Amanda]
  Amanda => [Michael, Michael, Daniel, Michael]
```
Метод выдаст число 3, сообщяющий что это третье свидание. 
Когда кто-то появляется впервые, вы должны использовать объект LinkedList 
(здесь используем LinkedList вместо ArrayList, т.к. он имеет более быстрый ввод в начало списка).

***ЗЫ** Под человеком подразумевается обычная строка с его именем.* 

***ЗЫЫ** Нельзя использовать методы функционального программирования (лямбды итп.).*

## КР 1.4. (15 баллов)
**Связные списки.** Написать метод rearrange, который переставляет порядок списка целочисленных чисел таким образом, что 
все значения на четных позициях встанут в обратном порядке в начале списка, а нечетные в конце списка в прямом порядке.
Например, ```[0, 1, 2, 3, 4, 5, 6, 7, 8, 9] => [8, 6, 4, 2, 0, 1, 3, 5, 7, 9]```.

В примере значения соответсвуют позициям, однако это не обязательное условие, список может быть произвольным.

Если в списке менее двух элементов, он должен вернуться без изменений.

Ваша задача написать метод класса LinkedIntList. Вы можете добавить приватные, вспомогательные методы,
однако вы не можете предполагать, что какие-либо конкретные методы доступны. Вам разрешено определять свои собственные 
переменные типа ListNode, но вы не можете создавать какие-либо новые узлы. Также вы не можете использовать какую-либо 
вспомогательную структуру данных для решения этой проблемы (без массива, ArrayList, стека, очереди, String и т. д.). 
Вы также не можете изменять какие-либо поля данных узлов. Вы ДОЛЖНЫ решить эту проблему, переставив ссылки в списке.
Ваше решение должно выполняться за время O (n), где n - длина списка.

Структура классов представлена ниже:
```java
 public class ListNode {
     public int data; // здесь хранятся данные
     public ListNode next; // ссылка на следующий элемент
     <constructors>
 }
 public class LinkedIntList {
     private ListNode front; // первый элемент списка
     <methods>
 }
```
